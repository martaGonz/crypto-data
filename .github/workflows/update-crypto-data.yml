name: Update Cryptocurrency Data

on:
  schedule:
    # Run every 5 minutes
    - cron: '*/5 * * * *'

  # Allow manual trigger
  workflow_dispatch:

jobs:
  update-data:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Fetch CoinGecko data
        run: |
          node - << 'EOF'
          const https = require('https');
          const fs = require('fs');

          // Fetch top 250 cryptocurrencies by market cap from CoinGecko
          const url = 'https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=250&sparkline=false&precision=4';

          const options = {
            headers: {
              'User-Agent': 'Mozilla/5.0 (compatible; CryptonApp/1.0)'
            }
          };

          https.get(url, options, (res) => {
            let data = '';

            res.on('data', (chunk) => {
              data += chunk;
            });

            res.on('end', () => {
              // Check HTTP status
              if (res.statusCode !== 200) {
                console.error('❌ API returned status code:', res.statusCode);
                console.error('Response:', data.substring(0, 200));
                process.exit(1);
              }

              try {
                const coins = JSON.parse(data);

                // Filter out unwanted coins (wrapped, derivatives, staked, etc.)
                const filteredCoins = coins.filter(coin => {
                  const name = (coin.name || '').toLowerCase();
                  const symbol = (coin.symbol || '').toLowerCase();
                  const id = (coin.id || '').toLowerCase();

                  // Specific wrapped/derivative coins to exclude (by ID to avoid false positives)
                  const unwantedIds = [
                    'weth', 'wbtc', 'steth', 'reth', 'wsteth', 'cbeth',
                    'meth', 'staked-ether', 'etherfi-ether',
                    'usdp', 'fei-usd', 'frax', 'lusd',
                    'synthetix-network-token', // Leveraged tokens from Synthetix
                    'thorchain-erc20', 'thorchain-rune',
                    'terra-luna-classic', 'luna-classic',
                    'test-coin', 'fake-usdt'
                  ];

                  // Keyword-based exclusions (more specific to avoid false positives)
                  const unwantedKeywords = [
                    'leveraged-', 'inverse-', 'bear-', 'bull-', '-2x', '-3x', '-5x', '-10x',
                    'test', 'fake', 'old coin', 'deprecated',
                    'wrapped-', 'staked-' // But NOT just "staked"
                  ];

                  // Check if coin ID is in unwanted list
                  if (unwantedIds.includes(id)) {
                    return false;
                  }

                  // Check keyword exclusions
                  const hasUnwantedKeyword = unwantedKeywords.some(keyword =>
                    name.includes(keyword) || symbol.includes(keyword)
                  );

                  if (hasUnwantedKeyword) {
                    return false;
                  }

                  // Exclude 2x/3x/5x leverage indicators in names
                  if (/\d+x\s/i.test(name) || /\d+x\s/i.test(symbol)) {
                    return false;
                  }

                  return true;
                });

                // Transform CoinGecko format to our app format
                const transformedCoins = filteredCoins.map((coin, index) => ({
                  symbol: coin.symbol.toUpperCase(),
                  name: coin.name,
                  id: coin.id,
                  current_price: coin.current_price || 0,
                  price_change_percentage_24h: coin.price_change_percentage_24h,
                  market_cap_rank: index + 1
                }));

                // Write to docs folder (served by GitHub Pages)
                const output = {
                  success: true,
                  timestamp: new Date().toISOString(),
                  count: transformedCoins.length,
                  data: transformedCoins
                };

                // Create docs directory if it doesn't exist
                if (!fs.existsSync('./docs')) {
                  fs.mkdirSync('./docs', { recursive: true });
                }

                fs.writeFileSync('./docs/crypto-data.json', JSON.stringify(output, null, 2));
                console.log('✅ Successfully updated crypto data with', transformedCoins.length, 'coins');
              } catch (error) {
                console.error('❌ Error parsing data:', error.message);
                console.error('Data received:', data.substring(0, 200));
                process.exit(1);
              }
            });
          }).on('error', (error) => {
            console.error('❌ Network error:', error.message);
            process.exit(1);
          });
          EOF

      - name: Calculate Support/Resistance Levels
        run: |
          node - << 'EOF'
          const https = require('https');
          const fs = require('fs');

          // Read current crypto data
          const cryptoData = JSON.parse(fs.readFileSync('./docs/crypto-data.json', 'utf8'));

          // Function to calculate pivot points and S/R levels
          const calculateSR = (prices, period = 10) => {
            const pivots = [];

            for (let i = period; i < prices.length - period; i++) {
              let isHigh = true, isLow = true;

              for (let j = 1; j <= period; j++) {
                if (prices[i] <= prices[i - j]) isHigh = false;
                if (prices[i] >= prices[i - j]) isLow = false;
                if (prices[i] <= prices[i + j]) isHigh = false;
                if (prices[i] >= prices[i + j]) isLow = false;
              }

              if (isHigh) pivots.push({ price: prices[i], type: 'high', index: i });
              if (isLow) pivots.push({ price: prices[i], type: 'low', index: i });
            }

            // Group into channels
            const channels = [];
            const maxWidth = (Math.max(...prices) - Math.min(...prices)) * 0.05; // 5% width

            for (let pivot of pivots) {
              let high = pivot.price, low = pivot.price, strength = 1;

              for (let other of pivots) {
                if (Math.abs(other.price - pivot.price) <= maxWidth && other !== pivot) {
                  high = Math.max(high, other.price);
                  low = Math.min(low, other.price);
                  strength++;
                }
              }

              channels.push({ high: Math.round(high * 10000) / 10000, low: Math.round(low * 10000) / 10000, strength });
            }

            // Sort by strength and return top 3
            return channels.sort((a, b) => b.strength - a.strength).slice(0, 3);
          };

          // Fetch historical data and calculate S/R for test coins (BTC, ETH only)
          const srData = {};
          const testCoinIds = ['bitcoin', 'ethereum']; // Test with BTC and ETH only
          const topCoins = cryptoData.data.filter(coin => testCoinIds.includes(coin.id));

          let processed = 0;
          const processCoins = () => {
            if (processed >= topCoins.length) {
              fs.writeFileSync('./docs/support-resistance.json', JSON.stringify({
                success: true,
                timestamp: new Date().toISOString(),
                count: Object.keys(srData).length,
                data: srData
              }, null, 2));
              console.log('✅ Generated S/R data for', Object.keys(srData).length, 'coins');
              return;
            }

            const coin = topCoins[processed];
            processed++;

            // Fetch 1 year of daily data for this coin
            const url = `https://api.coingecko.com/api/v3/coins/${coin.id}/market_chart?vs_currency=usd&days=365&interval=daily`;

            https.get(url, { headers: { 'User-Agent': 'Mozilla/5.0' } }, (res) => {
              let data = '';
              res.on('data', (chunk) => data += chunk);
              res.on('end', () => {
                try {
                  const result = JSON.parse(data);
                  const prices = result.prices.map(p => p[1]);

                  srData[coin.id] = {
                    symbol: coin.symbol,
                    '1D': calculateSR(prices.slice(-1), 1), // Last day
                    '1W': calculateSR(prices.slice(-7), 3),
                    '1M': calculateSR(prices.slice(-30), 5),
                    '3M': calculateSR(prices.slice(-90), 7),
                    '1Y': calculateSR(prices, 10)
                  };

                  console.log(`✅ Calculated S/R for ${coin.symbol}`);
                } catch (e) {
                  console.log(`⚠️ Skipping ${coin.symbol}: ${e.message}`);
                }

                processCoins();
              });
            }).on('error', () => {
              console.log(`⚠️ Network error for ${coin.symbol}`);
              processCoins();
            });
          };

          processCoins();
          EOF

      - name: Commit and push if changed
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          if git diff --quiet docs/crypto-data.json docs/support-resistance.json; then
            echo "No changes detected"
          else
            git add docs/crypto-data.json docs/support-resistance.json
            git commit -m "chore: update cryptocurrency data and support/resistance levels [skip ci]"

            # Retry logic for push conflicts
            for i in {1..3}; do
              if git push; then
                echo "✅ Successfully pushed"
                break
              else
                echo "Push attempt $i failed, pulling and retrying..."
                git pull --rebase origin main
              fi
            done
          fi
