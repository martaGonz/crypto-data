name: Update Cryptocurrency Data

on:
  schedule:
    # Run every 5 minutes
    - cron: '*/5 * * * *'

  # Allow manual trigger
  workflow_dispatch:

jobs:
  update-data:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Fetch CoinGecko data
        run: |
          node - << 'EOF'
          const https = require('https');
          const fs = require('fs');

          // Fetch top 250 cryptocurrencies by market cap from CoinGecko
          const url = 'https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=250&sparkline=false&precision=4';

          const options = {
            headers: {
              'User-Agent': 'Mozilla/5.0 (compatible; CryptonApp/1.0)'
            }
          };

          https.get(url, options, (res) => {
            let data = '';

            res.on('data', (chunk) => {
              data += chunk;
            });

            res.on('end', () => {
              // Check HTTP status
              if (res.statusCode !== 200) {
                console.error('❌ API returned status code:', res.statusCode);
                console.error('Response:', data.substring(0, 200));
                process.exit(1);
              }

              try {
                const coins = JSON.parse(data);

                // Filter out unwanted coins (wrapped, derivatives, staked, etc.)
                const filteredCoins = coins.filter(coin => {
                  const name = (coin.name || '').toLowerCase();
                  const symbol = (coin.symbol || '').toLowerCase();
                  const id = (coin.id || '').toLowerCase();

                  // Specific wrapped/derivative coins to exclude (by ID to avoid false positives)
                  const unwantedIds = [
                    'weth', 'wbtc', 'steth', 'reth', 'wsteth', 'cbeth',
                    'meth', 'staked-ether', 'etherfi-ether',
                    'usdp', 'fei-usd', 'frax', 'lusd',
                    'synthetix-network-token', // Leveraged tokens from Synthetix
                    'thorchain-erc20', 'thorchain-rune',
                    'terra-luna-classic', 'luna-classic',
                    'test-coin', 'fake-usdt'
                  ];

                  // Keyword-based exclusions (more specific to avoid false positives)
                  const unwantedKeywords = [
                    'leveraged-', 'inverse-', 'bear-', 'bull-', '-2x', '-3x', '-5x', '-10x',
                    'test', 'fake', 'old coin', 'deprecated',
                    'wrapped-', 'staked-' // But NOT just "staked"
                  ];

                  // Check if coin ID is in unwanted list
                  if (unwantedIds.includes(id)) {
                    return false;
                  }

                  // Check keyword exclusions
                  const hasUnwantedKeyword = unwantedKeywords.some(keyword =>
                    name.includes(keyword) || symbol.includes(keyword)
                  );

                  if (hasUnwantedKeyword) {
                    return false;
                  }

                  // Exclude 2x/3x/5x leverage indicators in names
                  if (/\d+x\s/i.test(name) || /\d+x\s/i.test(symbol)) {
                    return false;
                  }

                  return true;
                });

                // Transform CoinGecko format to our app format
                const transformedCoins = filteredCoins.map((coin, index) => ({
                  symbol: coin.symbol.toUpperCase(),
                  name: coin.name,
                  id: coin.id,
                  current_price: coin.current_price || 0,
                  price_change_percentage_24h: coin.price_change_percentage_24h,
                  market_cap_rank: index + 1
                }));

                // Write to docs folder (served by GitHub Pages)
                const output = {
                  success: true,
                  timestamp: new Date().toISOString(),
                  count: transformedCoins.length,
                  data: transformedCoins
                };

                // Create docs directory if it doesn't exist
                if (!fs.existsSync('./docs')) {
                  fs.mkdirSync('./docs', { recursive: true });
                }

                fs.writeFileSync('./docs/crypto-data.json', JSON.stringify(output, null, 2));
                console.log('✅ Successfully updated crypto data with', transformedCoins.length, 'coins');
              } catch (error) {
                console.error('❌ Error parsing data:', error.message);
                console.error('Data received:', data.substring(0, 200));
                process.exit(1);
              }
            });
          }).on('error', (error) => {
            console.error('❌ Network error:', error.message);
            process.exit(1);
          });
          EOF

      - name: Calculate Support/Resistance Levels
        run: |
          node - << 'EOF'
          const https = require('https');
          const fs = require('fs');

          // Read current crypto data
          const cryptoData = JSON.parse(fs.readFileSync('./docs/crypto-data.json', 'utf8'));

          // Calculate Average True Range
          function atr(ohlcv, len = 14) {
            const tr = [];
            for (let i = 0; i < ohlcv.length; i++) {
              if (i === 0) {
                tr.push(ohlcv[i].h - ohlcv[i].l);
                continue;
              }
              const hi = ohlcv[i].h, lo = ohlcv[i].l, pc = ohlcv[i - 1].c;
              tr.push(Math.max(hi - lo, Math.abs(hi - pc), Math.abs(lo - pc)));
            }
            const out = [];
            let sum = 0;
            for (let i = 0; i < tr.length; i++) {
              sum += tr[i];
              if (i >= len) sum -= tr[i - len];
              out.push(i >= len - 1 ? sum / len : null);
            }
            return out;
          }

          // Find pivot highs and lows
          function pivots(ohlcv, L = 5) {
            const P = [];
            for (let i = L; i < ohlcv.length - L; i++) {
              const h = ohlcv[i].h, l = ohlcv[i].l;
              let hi = true, lo = true;
              for (let k = 1; k <= L; k++) {
                if (ohlcv[i - k].h >= h || ohlcv[i + k].h >= h) hi = false;
                if (ohlcv[i - k].l <= l || ohlcv[i + k].l <= l) lo = false;
                if (!hi && !lo) break;
              }
              if (hi) P.push({ type: 'H', price: h, idx: i });
              if (lo) P.push({ type: 'L', price: l, idx: i });
            }
            return P;
          }

          // Create initial bands around pivots
          function initialBands(pivots, ohlcv, atrArr, bandPct = 0.002) {
            return pivots.map(p => {
              const i = p.idx;
              const w = Math.max(bandPct * p.price, 0.5 * (atrArr[i] ?? 0));
              const low = p.price - w;
              const high = p.price + w;
              return { low, high, pivots: [p], touches: 0, last_touch_t: null };
            });
          }

          // Count how many bars touch each band
          function countTouches(band, ohlcv) {
            let t = 0, last = null;
            for (const b of ohlcv) {
              if (b.h >= band.low && b.l <= band.high) {
                t++;
                last = b;
              }
            }
            band.touches = t;
            band.last_touch_t = last;
          }

          // Merge overlapping bands
          function mergeOverlaps(bands, mergeGapPct = 0.0015) {
            if (!bands.length) return [];
            bands.sort((a, b) => a.low - b.low);
            const out = [bands[0]];
            for (let i = 1; i < bands.length; i++) {
              const cur = bands[i];
              const last = out[out.length - 1];
              const gap = cur.low - last.high;
              const threshold = last.high * mergeGapPct;
              if (gap <= threshold) {
                last.high = Math.max(last.high, cur.high);
                last.low = Math.min(last.low, cur.low);
                last.pivots.push(...cur.pivots);
                last.touches += cur.touches;
              } else {
                out.push(cur);
              }
            }
            return out;
          }

          // Calculate S/R for a timeframe
          function calculateSR(ohlcv, pivotLen = 5, bandPct = 0.002, topK = 6) {
            if (ohlcv.length < 30) return [];

            const atrArr = atr(ohlcv, 14);
            const pivotPoints = pivots(ohlcv, pivotLen);

            if (pivotPoints.length === 0) return [];

            let bands = initialBands(pivotPoints, ohlcv, atrArr, bandPct);
            bands.forEach(b => countTouches(b, ohlcv));
            bands = mergeOverlaps(bands, 0.0015);

            // Sort by strength (touches) descending, return top K
            return bands
              .filter(b => b.touches >= 2)
              .sort((a, b) => b.touches - a.touches)
              .slice(0, topK)
              .map(b => ({
                high: Math.round(b.high * 100) / 100,
                low: Math.round(b.low * 100) / 100,
                strength: b.touches
              }));
          }

          // Convert price data to OHLCV format
          function priceToOHLCV(prices, highs, lows, volumes) {
            return prices.map((c, i) => ({
              c: c,
              h: highs[i],
              l: lows[i],
              v: volumes[i] || 0
            }));
          }

          // Fetch historical data and calculate S/R
          const srData = {};
          const testCoinIds = ['bitcoin'];
          const topCoins = cryptoData.data.filter(coin => testCoinIds.includes(coin.id));

          let processed = 0;
          const processCoins = () => {
            if (processed >= topCoins.length) {
              fs.writeFileSync('./docs/support-resistance.json', JSON.stringify({
                success: true,
                timestamp: new Date().toISOString(),
                count: Object.keys(srData).length,
                data: srData
              }, null, 2));
              console.log('✅ Generated S/R data for', Object.keys(srData).length, 'coins');
              return;
            }

            const coin = topCoins[processed];
            processed++;

            const url = `https://api.coingecko.com/api/v3/coins/${coin.id}/market_chart?vs_currency=usd&days=365&interval=daily`;

            https.get(url, { headers: { 'User-Agent': 'Mozilla/5.0' } }, (res) => {
              let data = '';
              res.on('data', (chunk) => data += chunk);
              res.on('end', () => {
                try {
                  const result = JSON.parse(data);

                  // Extract OHLCV data
                  const fullOHLCV = result.prices.map((p, i) => ({
                    c: p[1],
                    h: p[1] * 1.01, // Approximate - CoinGecko doesn't give true OHLC
                    l: p[1] * 0.99,
                    v: result.volumes ? result.volumes[i][1] : 0
                  }));

                  srData[coin.id] = {
                    symbol: coin.symbol,
                    '1D': calculateSR(fullOHLCV.slice(-30), 5, 0.002, 6),
                    '1W': calculateSR(fullOHLCV.slice(-60), 5, 0.002, 6),
                    '1M': calculateSR(fullOHLCV.slice(-90), 5, 0.002, 6),
                    '3M': calculateSR(fullOHLCV.slice(-180), 5, 0.002, 6),
                    '1Y': calculateSR(fullOHLCV, 5, 0.002, 6)
                  };

                  console.log(`✅ Calculated S/R for ${coin.symbol}`);
                } catch (e) {
                  console.log(`⚠️ Skipping ${coin.symbol}: ${e.message}`);
                }

                processCoins();
              });
            }).on('error', () => {
              console.log(`⚠️ Network error for ${coin.symbol}`);
              processCoins();
            });
          };

          processCoins();
          EOF

      - name: Commit and push if changed
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          if git diff --quiet docs/crypto-data.json docs/support-resistance.json; then
            echo "No changes detected"
          else
            git add docs/crypto-data.json docs/support-resistance.json
            git commit -m "chore: update cryptocurrency data and support/resistance levels [skip ci]"

            # Retry logic for push conflicts
            for i in {1..3}; do
              if git push; then
                echo "✅ Successfully pushed"
                break
              else
                echo "Push attempt $i failed, pulling and retrying..."
                git pull --rebase origin main
              fi
            done
          fi
